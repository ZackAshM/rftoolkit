"""Gain and Impulse Repsonse functions from a transmitting antenna to receiving antenna measurement.@author: zackashm"""from .waveform import Waveformfrom .VNA import S2Pimport numpy as npfrom scipy.interpolate import interp1dfrom scipy.constants import cfrom warnings import warndef calcGainFromPulse(dataRx, dataPulse, gainTx, dist, addComponentsS21=None, verbose=1):    '''    Calculates the gain from a measurement where a pulse is sent from Tx antenna to Rx antenna.    The data is assumed [[time (s)], [voltage (V)]] form. Each data is interpolated over the least-sampled    data frequency space.        The gain is calculated using the following:    1. *Use Waveform.calc_fft to get the relative gain of dataRx and dataPulse:        dB = 10 * log10( abs(rfft)**2 / 50)    2. Create scipy.interpolate.interp1d of each relative gain with the    corresponding frequency data given by waveform.calc_fft. The less-sampled frequency space    is used for the full calculation.    3. Calculate the gain via https://www.antenna-theory.com/basics/friis.php :        gain = sig_dB - pul_dB + friis_term - transmitted_dB (+ addComponentsS21)    where friis_term is the physical propagation term given by        friis_term = 20 * log10( abs( (4 * pi * dist * fHz) / c ) )    and addComponentsS21 are S21 data of additional components such as cables or attenuators.        *The data are converted to Waveform objects if not given as Waveform. A standard procedure would be    cleaning the data as Waveform objects before calling this function.    Parameters    ----------    dataRx : (2,1d) array, or Waveform        An array containing [[time (s)], [voltage (V)]] data received.    dataPulse : (2,1d) array, or Waveform        An array containing [[time (s)], [voltage (V)]] data transmitted.    gainTx : (2,1d) array        An array containing [[frequency in Hz], [gain in dBi] for the transmitting antenna.    dist : float, or tuple(2)        The distance in meters used in the physical friis term. If given as (float, float), the distance is treated        as frequency dependent, where the distance is linearly interpolated from the first value to the second        over the determined frequency space.    addComponentsS21 : list[(2,1d) array], optional        A list of S21 data in [[frequency in Hz], [gain in dBm]] from a VNA associated with additional        components such as cables or attenuators. All components are assumed 50 Ohms, so the S21's are simply added (in dB).        Note that the sign of the data should correspond to whether the component adds or subtracts to the gain.    verbose : int, optional        If 0: No print messages. If 1: warning messages only will be printed when there is data inconsistency.         If 2: Progress messages are printed at each step. Default is 1.    Returns    -------    evalFreqHz : array        Frequency array in Hz used for evaluation. This corresponds to the smallest band overlap and smallest         samplerate of all the data.    gainRx : array        Gain array in dB, calculated as described above.    '''        if verbose > 1:        print('Starting gain from pulse calculation')        addComponents = not (addComponentsS21 is None)    if (not addComponents) and (verbose > 1):        print('Found no additional components')        # Step 0. convert data and make consistency checks        # -- convert to waveform objects    wfmRx = dataRx if isinstance(dataRx, Waveform) else Waveform(data=dataRx)    wfmPulse = dataPulse if isinstance(dataPulse, Waveform) else Waveform(data=dataPulse)        # -- Check data lengths and samplerates    if verbose > 1:        print('Checking data consistency')    wfmRxSamplerate = wfmRx.samplerate    wfmPulseSamplerate = wfmPulse.samplerate    if wfmRx.samplerate != wfmPulse.samplerate:        if verbose > 0:            warn(f'dataRx and pulseRx have different samplerates: {wfmRxSamplerate} S/s, {wfmPulseSamplerate} S/s')        elif verbose > 1:            print(f'Samplerates passed: dataRx and pulseRx have same samplerates: {wfmRxSamplerate} S/s, {wfmPulseSamplerate} S/s')    wfmRxSize = wfmRx.datasize    wfmPulseSize = wfmPulse.datasize    if wfmRxSize != wfmPulseSize:        if verbose > 0:            warn(f'dataRx and pulseRx have different data lengths: {wfmRxSize}, {wfmPulseSize}')        elif verbose > 1:            print(f'Lengths passed: dataRx and pulseRx have same data lengths: {wfmRxSize}, {wfmPulseSize}')        # -- TO DO: Check consistency with addComponentsS21 ( take caution of datalength change in Waveform :( )    if addComponents:        if verbose > 1:            print('Checking and intializing addComponentsS21')        if len(np.array(addComponentsS21).shape) == 2:            addComponentsS21 = np.array([addComponentsS21])        else:            addComponentsS21 = np.array(addComponentsS21)        #for comp in addComponentsS21:                # Step 1. Get FFTs    if verbose > 1:        print('Calculating FFTs')    fftRx = wfmRx.calc_fft(rfft=True)[0::2] # Hz, dB    fftPulse = wfmPulse.calc_fft(rfft=True)[0::2] # Hz, dB        # Step 2. Interpolate    if verbose > 1:        print('Interpolating')    # -- find the evaluation frequency:    evalFreqMin = max((fftRx[0][0], fftPulse[0][0], gainTx[0][0]))    evalFreqMax = min((fftRx[0][-1], fftPulse[0][-1], gainTx[0][-1]))    evalFreqSamp = max((np.float64('{:0.5e}'.format(np.diff(fftRx[0]).mean())),                         np.float64('{:0.5e}'.format(np.diff(fftPulse[0]).mean())),                        np.float64('{:0.5e}'.format(np.diff(gainTx[0]).mean()))))    if addComponents:        for addCompS21 in addComponentsS21:            evalFreqMin = max((evalFreqMin, addCompS21[0][0]))            evalFreqMax = min((evalFreqMax, addCompS21[0][-1]))            evalFreqSamp = max((evalFreqSamp, np.float64('{:0.5e}'.format(np.diff(addCompS21[0]).mean()))))    if verbose > 1:        print(f'Obtained evaluation frequency of (min, max, step): ({evalFreqMin}, {evalFreqMax}, {evalFreqSamp}) Hz')    evalFreqHz = np.arange(evalFreqMin+evalFreqSamp, evalFreqMax, evalFreqSamp)        # -- interpolate    interpfftRx = interp1d(fftRx[0], fftRx[1])    interpfftPulse = interp1d(fftPulse[0], fftPulse[1])    interpGainTx = interp1d(gainTx[0], gainTx[1])    if addComponents:        interpCompsS21 = []        for addCompS21 in addComponentsS21:            interpCompsS21.append(interp1d(addCompS21[0],addCompS21[1]))        # Step 3. Calculate Gain    if verbose > 1:        print('Interpolation done. Calculating gain')        # -- prepare physical term    evalDist = np.linspace(dist[0], dist[1], evalFreqHz.size) if isinstance(dist, tuple) else dist * np.ones(evalFreqHz.size)        # -- -- the friis term containing the info about the physical environment    # -- -- https://www.antenna-theory.com/basics/friis.php    friisTerm = 20 * np.log10( np.abs((4 * np.pi * evalDist * evalFreqHz) / c ) ) # in dB        # -- calculate gain    gainRx = interpfftRx(evalFreqHz) - interpfftPulse(evalFreqHz) + friisTerm - interpGainTx(evalFreqHz)    if addComponents:        for addCompS21 in interpCompsS21:            gainRx += addCompS21(evalFreqHz)        # -- return freq and gain    if verbose > 1:        print('Gain calculation complete')    return (evalFreqHz, gainRx)def calcImpulseResponseFromPulse(dataRx, dataPulse, gainTx, dist, addComponentsS21MagPhase=None, method='simple',                                 nsNoiseWindow=None, verbose=1):    '''    Calculates the impulse response from a measurement where a pulse is sent from Tx antenna to Rx antenna.    The data is assumed [[time (s)], [voltage (V)]] form. Each data is interpolated over the least-sampled    data frequency space.        *The data are converted to Waveform objects if not given as Waveform. A standard procedure would be    cleaning the data as Waveform objects before calling this function.    Parameters    ----------    dataRx : (2,1d) array, or Waveform        An array containing [[time (s)], [voltage (V)]] data received.    dataPulse : (2,1d) array, or Waveform        An array containing [[time (s)], [voltage (V)]] data transmitted.    gainTx : (2,1d) array        An array containing [[frequency in Hz], [gain in dBi] for the transmitting antenna.    dist : float, or tuple(2)        The distance in meters used in the physical friis term. If given as (float, float), the distance is treated        as frequency dependent, where the distance is linearly interpolated from the first value to the second        over the determined frequency space.    addComponentsS21MagPhase : list[(3,1d) array], list[S2P], optional        A list of S21 data in [[frequency in Hz], [gain in dBm], [phase in deg]] from a VNA associated with additional        components such as cables or attenuators. Alternatively, a list of rftoolkit.VNA.S2P.         All components are assumed 50 Ohms, so the S21's are simply added (in dB).        Note that the sign of the data should correspond to whether the component adds or subtracts to the gain.    method : str, optional        The method of calculation. If 'simple', the calculation is done using deconvolution via division in frequency domain.        If 'wiener', the calculation uses Wiener deconvolution by estimating an SNR from dataRx and nsNoiseWindow.        The default is 'simple'.    nsNoiseWindow : tuple(2)        The time window in nanoseconds to consider noise for SNR estimation in the Wiener deconvolution. If None, but        'wiener' method is chosen, the first 5 ns of the data is considered the noise window.    verbose : int, optional        If 0: No print messages. If 1: warning messages only will be printed when there is data inconsistency.         If 2: Progress messages are printed at each step. Default is 1.    Returns    -------    ndarray(2,)        The [time [ns], impulse response [m/ns]] data array.    '''        if verbose > 1:        print('Starting impulse response calculation')            addComponents = not (addComponentsS21MagPhase is None)    if (not addComponents) and (verbose > 1):        print('Found no additional components')            # Step 0. convert data and make consistency checks        # -- convert to waveform objects    wfmRx = dataRx if isinstance(dataRx, Waveform) else Waveform(data=dataRx)    wfmPulse = dataPulse if isinstance(dataPulse, Waveform) else Waveform(data=dataPulse)        # -- Check data lengths and samplerates    if verbose > 1:        print('Checking data consistency')    wfmRxSamplerate = wfmRx.samplerate    wfmPulseSamplerate = wfmPulse.samplerate    if wfmRx.samplerate != wfmPulse.samplerate:        if verbose > 0:            warn(f'dataRx and pulseRx have different samplerates: {wfmRxSamplerate} S/s, {wfmPulseSamplerate} S/s')        elif verbose > 1:            print(f'Samplerates passed: dataRx and pulseRx have same samplerates: {wfmRxSamplerate} S/s, {wfmPulseSamplerate} S/s')    wfmRxSize = wfmRx.datasize    wfmPulseSize = wfmPulse.datasize    if wfmRxSize != wfmPulseSize:        if verbose > 0:            warn(f'dataRx and pulseRx have different data lengths: {wfmRxSize}, {wfmPulseSize}')        elif verbose > 1:            print(f'Lengths passed: dataRx and pulseRx have same data lengths: {wfmRxSize}, {wfmPulseSize}')        # -- TO DO: Check consistency with addComponentsS21 ( take caution of datalength change in Waveform :( )    if addComponents:        if verbose > 1:            print('Checking and intializing addComponentsS21MagPhase')        if len(np.array(addComponentsS21MagPhase).shape) < 3:            addComponentsS21MagPhase = np.array([addComponentsS21MagPhase])        else:            addComponentsS21MagPhase = np.array(addComponentsS21MagPhase)        compsVNA = []        for comp in addComponentsS21MagPhase:            if isinstance(comp, S2P):                compsVNA.append(comp)            else:                compsVNA.append(S2P(data=[comp[0],[],[],[],[],comp[1],comp[2],[],[]]))        # Step 1. Get FFTs    if verbose > 1:        print('Calculating FFTs')    fftRx = wfmRx.calc_fft(rfft=True)[:2] # Hz, linear    fftPulse = wfmPulse.calc_fft(rfft=True)[:2] # Hz, linear        # Step 2. Determine the evaluation frequency    if verbose > 1:        print('Determining the evaluation frequency')    evalFreqMin = max((fftRx[0][0], fftPulse[0][0], gainTx[0][0]))    evalFreqMax = min((fftRx[0][-1], fftPulse[0][-1], gainTx[0][-1]))    evalFreqSamp = max((np.float64('{:0.5e}'.format(np.diff(fftRx[0]).mean())),                         np.float64('{:0.5e}'.format(np.diff(fftPulse[0]).mean())),                        np.float64('{:0.5e}'.format(np.diff(gainTx[0]).mean()))))    if addComponents:        for addComp in compsVNA:            evalFreqMin = max((evalFreqMin, addComp.fHz[0]))            evalFreqMax = min((evalFreqMax, addComp.fHz[-1]))            evalFreqSamp = max((evalFreqSamp, addComp.steprate))    if verbose > 1:        print(f'Obtained evaluation frequency of (min, max, step): ({evalFreqMin}, {evalFreqMax}, {evalFreqSamp}) Hz')    evalFreqHz = np.arange(evalFreqMin+evalFreqSamp, evalFreqMax, evalFreqSamp)        # Step 3. Interpolate real and imag data    if verbose > 1:        print('Interpolating real and imaginary values of the data FFTs')    interpRxReal = interp1d(fftRx[0], np.real(fftRx[1]))    interpRxImag = interp1d(fftRx[0], np.imag(fftRx[1]))    interpPulseReal = interp1d(fftPulse[0], np.real(fftPulse[1]))    interpPulseImag = interp1d(fftPulse[0], np.imag(fftPulse[1]))    interpGainTx = interpGainTx = interp1d(gainTx[0], gainTx[1]) # assume real, nondispersive    if addComponents:        interpCompsVNAReal = []        interpCompsVNAImag = []        for addComp in compsVNA:            interpCompsVNAReal.append(interp1d(addComp.fHz, np.real(addComp.s21complex)))            interpCompsVNAImag.append(interp1d(addComp.fHz, np.imag(addComp.s21complex)))        # -- prepare physical term    evalDist = np.linspace(dist[0], dist[1], evalFreqHz.size) if isinstance(dist, tuple) else dist * np.ones(evalFreqHz.size)        # Step 4. Perform deconvolution    if method == 'simple':        if verbose > 1:            print('Simple method selected. Calculating deconvolution via FFT division')                    Vr = interpRxReal(evalFreqHz) + 1j*interpRxImag(evalFreqHz) # received data        Vp = interpPulseReal(evalFreqHz) + 1j*interpPulseImag(evalFreqHz) # pulse data        Gt = interpGainTx(evalFreqHz)        friisFactor = (c * evalDist) / (1j * evalFreqHz)                compResponse = 1        if addComponents:            for addCompReal, addCompImag in zip(interpCompsVNAReal, interpCompsVNAImag):                compResponse *= addCompReal(evalDist) + 1j*addCompImag(evalDist)                impulseResponseRxfft = (friisFactor * compResponse * Vr) / (Vp * Gt)                if verbose > 1:            print('Completed impulse response calculation in frequency domain.')            elif method == 'wiener':        if verbose > 1:            print('Wiener method selected. Calculating deconvolution via Wiener deconvolution')    else:        raise ValueError(f'Method "{method}" is unrecognized')        # Step 5. Convert to time domain    if verbose > 1:        print('Calculating in time domain.')        dt = 1 / (evalFreqSamp*evalFreqHz.size)    nsTime = np.arange(0,evalFreqHz.size) * dt * 1e-9        impulseResponseRx = np.fft.irfft(impulseResponseRxfft, len(impulseResponseRxfft))        return (evalFreqHz, 10*np.log10(np.abs(impulseResponseRxfft)**2 / 50), nsTime, impulseResponseRx)